Array
	배열 생성자
	
	const a = 1;
	const b = 2;
	
	값을 여러개 담을 때 는 객체
	
	값을 담기 위해서는 배열 객체를 생성해야 한다.
	
	1. new 연산자를 통해서 생성
		생성자 인수로 값을 여러개 할당
		const a = new Array(1,2,3,4,5);
		
		인수 1개 - 값으로 인식하는 것이 아니라 배열의 공간 갯수로 인식 (유의점)
		(인수가 1개 -> 반드시 숫자(양수), 음수, 문자 -> 오류)
		const a = new Array(3); -> 빈 공간 3개
		
	2. 대괄호 연산자[]를 통해서 생성
		const a = [1,2,3,4,5];
		
		
	3. 배열은 각 요소의 순서 번호가 자동으로 생성이 된다

	4. 순서 번호에 따라 접근을 하려면 대괄호 -- 배열변수[순서번호]
		예) const a = ["aa", "bb", "cc"];
			a[0];
			
	5. 배열 객체
		["apple", "mango", "orange"]
		
		객체 구성
		{
			속성 : 값, // 원시타입 + 객체 --> 다 담을 수 있다 --> 배열은 객체 --> 배열도 다 담을 수 있다
			속성 : 값, 
		}
		
		["apple", "mango", "orange"]
		{
			"0" : "apple",
			"1" : "mango",
			"2" : "orange",
		}
		
		
		접근 대괄호 [순서 번호 - 인덱스 번호]로 접근
		
		
		배열 데이터를 변경
			- 이미 있는 인덱스 번호의 값에 대입을 하면 변경
				a[1] = "변경할 값";
				a[2] = "변경할 값";
					예) const a = ["aa", "bb", "cc"];
						a[1] = "water melon";
		
		
		배열 데이터를 추가
			- 없는 인덱스에 값을 대입하면 추가된다
				a[3] = "추가할 값";
					예) const a = ["aa", "bb", "cc"];
						a[3] = "water";
						
			- 배열 생성자에서 제공되는 메서드
				.push() : 배열의 끝에 추가 --> 현재의 배열 갯수 반환	
					예) a.push("melon");
					
				.unshift() : 배열의 앞에 추가 --> 현재의 배열 갯수를 반환
					예) a.unshift("banana");
		
		
		배열 데이터를 삭제
			- delete 배열변수[인덱스번호];
				delete a[2];
					예) const a = ["aa", "bb", "cc"];
						delete a[2];
			
			- 배열 생성자에서 제공되는 메서드
				.pop() : 배열의 마지막 요소를 삭제 --> 제거된 요소를 반환
					예) let removed = a.pop();
						removed;
						
				.shift() : 배열의 첫번째 요소를 삭제 --> 제거된 요소를 반환
					예) let removed = a.shift();
						removed;
						
		
		배열의 값은 - 모든 데이터(객체 이므로)
			const a = [1,2,3,4,"aa", "bb", "cc", [1,2,3,4], {name : "이름", age : 40}];
			const a = ["aa", "bb", "cc", function(){}];
			
			
		배열 생성자
			- 속성
				.length : 배열의 요소의 갯수
					const a = ["aa", "bb", "cc"];
					for (let i = 0; i < a.length; i++) {
						console.log(a[i]);
					}	
					
				
				.length 속성에 값을 대입하면?
					- 배열의 갯수가 변경
						예) const a = ["aa", "bb", "cc"];
							a.length = 10;
							
							
			- 메서드
				.concat - 여러 배열 객체를 하나로 합칠 때 사용
					예) const a = [0,1,2,3,4];
						const b = [5,6,7,8,];
						const c = [11,12,13,14];
						const d = a.concat(b,c);
				
				.includes(요소) - 특정 요소가 포함이 되어 있는지 체크
					예) const a = ["aa", "bb", "cc", "dd"];
						a.includes("aa");
					
					
				.indexOf("요소명") - 요소가 위치하고 있는 배열의 인덱스를 반환
								   - 요소를 찾지 못하면 -1을 반환
								   - 찾는 방향이 왼쪽 -> 오른쪽
					예) const a = ["aa", "bb", "cc", "dd"];
						a.indexOf("cc");
						
						
				.lastIndexOf("요소명") - indexOf와 동일 -> 찾는 방향이 오른쪽 -> 왼쪽
				
				
				.join("구분자") -- 구분자로 배열 요소를 결합하여 문자열로 반환
								-- 구분자의 기본값(아무것도 입력하지 않았을 경우) 콤마(,)
								
								
				.String.split("구분자") -> 문자열을 구분자로 분해하여 배열 객체로 반환
						예) const a = ["apple", "banana", "water melon", "cup", "buket", "apple"];
							let str = a.join("#");
							str;
							str = str.split("#");
				
				
				.isArray() -> 배열 객체인지 아닌지를 구분할 때 
							배열변수 a instanceof Array;
								예) Array.isArray(a);
				
				
참고)
	객체 변수 instanceof 객체 생성자
		--> 객체 변수가 객체 생성자로 부터 생성된 인스턴스 주소를 가지고 있는가?
		
	a instanceof Array --> Array 생성자로 생성된 객체인가?
	
				
				.keys() -> 배열의 전체 인덱스번호를  반환
					예) const a = ["apple", "banana", "water melon", "cup", "buket", "apple"];
						Object.keys(a);
				
				
				.shift() -> 가장 처음 요소를 제거, 제거된 요소를 반환
				.pop() -> 가장 마지막 요소 제거, 제거된 요소를 반환
				.splice() -> 배열의 중간 요소를 제거(추가할 요소를 등록하지 않으면됨)
								예) a.splice(1, 2);
				
				.unshift() -> 가장 처음 요소에 추가, 추가 이후에 변경된 갯수를 반환	
				.push() -> 가장 마지막 요소에 추가, 추가 이후에 변경된 갯수를 반환
				.splice() -> 배열의 중간에 추가(삭제 갯수를 0으로 하면됨)
								예) a.splice(1, 0, 1,2);
				
				
				.reverse() -> 배열의 순서를 반전
				
				.slice(시작,종료) -> 시작 이상, 종료 미만 만큼 배열 요소를 잘라서 반환
								  -> 종료가 없으면 시작부터 끝
								  
								  -> 배열 객체를 복사
								  -> 반환값으로 배열은 새로 생성된 데이터(인스턴스)
										예) const a = ["apple", "banana", "water melon", "cup", "buket"];
											const b = a.slice(1);
				
				
				.splice(시작, 삭제갯수, ...시작점부터 추가할 요소)
								- 삭제하고 시작점 부터 추가
								
								예1) const a = ["apple", "banana", "water melon", "cup", "buket"];
								     a.splice(1, 1, 1,2);
								
						---------------------------------------------------------------------------	
						
								- 배열의 중간에 값을 추가 할 때
								
								예2) const a = ["apple", "banana", "water melon", "cup", "buket"];
								     a.splice(1, 0, 1,2);
									 
				
				.sort() - 오름차순 정렬
				
				
				.forEach -> 배열 객체를 순회 O / 반환 X - 단순 순회
				
					.forEach(function(순회한 요소, 요소의 인덱스, forEach를 호출한 배열 객체의 주소 변수){
					
					});
						예) const a = ["key", "apple", "banana", "water melon", "cup", "buket"];
							a.forEach(function(el, i) {
								console.log(el, i);
							});
				--------------------------------------------------------------------------------						
						예) function forEach(callback) {
								const element = "배열의 각 요소";
								const index = "배열의 각 요소의 인덱스";
								
								callback(element, index);
							}

							const callbackFunc = function(el, i) {
								console.log("el",el);
								console.log("i",i);
							};
							
				---------------------------------------------------------------------------------
				
						a.forEach(function(el, i, _a){
							//반복 순회 -> 원 데이터를 변경 _a -> forEach를 호출한 배열 주소를 공유
						});
							
							예) const a = [0,1,2,3,4,5];
								a.forEach(function(el, i, _a) {
									_a[i] = el * el;
								});
								a;
							
						
				.map
					.map(function(순회한 요소, 요소의 인덱스, forEach를 호출한 배열 객체의 주소 변수){
						//배열 데이터 처리
						return 반환값;
					});
				
						예) const a = [0,1,2,3,4,5,6];
							const b = a.map(function(el) {
							
								 return el + "#";
								
							});
							
					----------------------------------------------------------	
					
						예)	const a = [0,1,2,3,4,5,6];
							const b = a.map(function(el, i, _a) {
								 _a[i] = "(변경)" + el;
									return el + "#";
								
							});
					
				
				.filter
					.filter(function(순회한 요소, 요소의 인덱스, forEach를 호출한 배열 객체의 주소 변수){
							//테스트 구간
							- 테스트 성공시 return true; --> 순회한 요소가 반환
							- 테스트 실패시 return false; --> 건너뛴다
						});
						
								예) const a = [0,1,2,3,4,5,6,7,8,9,10];
									const b = a.filter(function(el) {
											// 테스트 결과 true -> b로 값을 반환
										if ( el % 2 == 0) { 	// 짝수이면 테스트 통과 true
											   return true;
										} else { 	// 짝수가 아니면 false를 반환
												return false;
										};
					
				.reduce
					.reduce(function(이전 연산 결과, 현재 요소 값){
					
							return 이전 연산 결과 +-*/ 현재 요소값
					});
					
						예) const a = [0,1,2,3,4,5,6,7,8,9,10];
							const b = a.reduce(function(acc, el){
								   console.log("acc",acc, "el", el);

									return acc + el;
							});
							
					0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
					
					acc - 0, el - 1
					acc - 1(0+1), el - 2
					acc - 3(1+2), el - 3
					acc - 6(3+3), el - 4
					acc - 10(6+4), el - 5
					...
					
					합성 합
				
				
